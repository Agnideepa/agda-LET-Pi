\documentclass[12pt]{article}

\usepackage[margin=0.8in]{geometry}
\usepackage{agda}
\usepackage{catchfilebetweentags}

% The following packages are needed because unicode
% is translated (using the next set of packages) to
% latex commands. You may need more packages if you
% use more unicode characters:

\usepackage{amssymb}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{alphabeta}

% This handles the translation of unicode to latex:

\usepackage{ucs}
\usepackage[utf8]{inputenc}
\usepackage{autofe}

\usepackage{newunicodechar}
\newunicodechar{‚Çë}{\textsubscript{e}}
\newunicodechar{‚àÄ}{\ensuremath{\mathnormal\forall}}
\newunicodechar{‚Ñï}{$\mathbb{N}$}
\newunicodechar{ùïì}{$\mathbbm{b}$}
\newunicodechar{‚ä¢}{$\vdash$}
\newunicodechar{‚à∂}{:}
\newunicodechar{‚à∑}{::}
\newunicodechar{‚ÇÅ}{$_1$}
\newunicodechar{‚ÇÇ}{$_2$}
\newunicodechar{‚ÇÉ}{$_3$}

\usepackage{caption}
\usepackage{subcaption}

\usepackage{tikz}
\usetikzlibrary{topaths}
\tikzstyle{every picture}+=[remember picture,inner xsep=0,inner ysep=0.25ex]

\usepackage{xcolor}
\usepackage{ebproof}
\usepackage[export]{adjustbox}
\usepackage{changepage}

\begin{document}
	\section{LET}
	
			LET, as outlined in the Background section, is a conventional high-level language, so I will talk about a few design decisions made during its implementation to take advantage of dependent types.

			\subsection{Variables, environments and de Bruijn indices}
	
	
	Variable names are pointers to variable bindings in the environment. A de Bruijn index is an alternate way of referring to a binding using its level, with the innermost level being 0. So we replace variable names with natural numbers and avoid additional code complexity:
	\begin{center}
	let x = \tikz[baseline=(node5.base)]\node (node5){$\langle \rangle$}; in let y = \tikz[baseline=(node6.base)]\node (node6){($\langle \rangle$,$\langle \rangle$)}; in (\tikz[baseline=(node7.base)]\node (node7){y};,\tikz[baseline=(node8.base)]\node (node8){x};)
	\textbf{becomes}
	let \tikz[baseline=(node1.base)]\node (node1){$\langle \rangle$}; in let \tikz[baseline=(node2.base)]\node (node2){($\langle \rangle$,$\langle \rangle$)}; in (\tikz[baseline=(node3.base)]\node (node3){0};,\tikz[baseline=(node4.base)]\node (node4){1};)
	
	\begin{tikzpicture}[overlay]
		\draw[-latex, color=red] (node3.south) -- ++(0,-1.8ex) -| (node2.south);
		\draw[-latex, color=green] (node4.north) -- ++(0,+1.5ex) -| (node1.north);
		
		\draw[-latex, color=red] (node7.south) -- ++(0,-1.5ex) -| (node6.south);
		\draw[-latex, color=green] (node8.north) -- ++(0,+1.7ex) -| (node5.north);
	\end{tikzpicture}
   \end{center}

  However, we cannot allow just any natural number to be used in place of a variable name. This can lead to errors during evaluation. In the example above, if 0 is replaced with 5, we will get an error because there is no binding at level 5! In other words, this variable is not in scope. The data structures used to represent indices and environments help us prevent this problem. 
  
  Consider a LET value environment œÅ and its corresponding type environment Œì. œÅ is a vector of values, Œì is a vector of value types, and $\forall$x $\in$ [0 ,..., len(œÅ) - 1].œÅ[x] is of type Œì[x]. In our implementation of LET, we represent œÅ as a value of type \textcolor{blue}{Œì env}, where Œì is a length-indexed vector that holds values of type \textcolor{blue}{$\mathbbm{b}$}, i.e., Œì is of type \textcolor{blue}{Vec $\mathbbm{b}$ n} and \textcolor{blue}{n} = len(Œì). In this way, we `connect' œÅ to its type environment Œì.
  
  \begin{figure}[!htbp]
  	\begin{subfigure}[b]{0.6\textwidth}
  		\ExecuteMetaData[Languages/Let.tex]{env-declare}
  		\caption{Data type for environments}
  		\label{fig:f1}
  		
  	\end{subfigure}
  	\hfill \vline
  	\begin{subfigure}[b]{0.4\textwidth}
  		\ExecuteMetaData[Languages/Let.tex]{debruijn}
  		\caption{Constructor for variables}
  		\label{fig:f2}
  	\end{subfigure}
  	\hfill
  	\caption{Variables and environments}
  \end{figure}

	The type environment Œì for any LET expression is known at compile time. Each binding in the current environment contributes one element to Œì. The Agda term \textcolor{teal}{var\textsubscript{e} $x$} represents a LET variable where $x$ corresponds to a de Bruijn index, and the typechecker ensures that $x$ is of type \textcolor{blue}{Fin n} where \textcolor{blue}{n} = len(Œì). Therefore, $x$ must be in the range [0 ,.., len(Œì) - 1] and \textcolor{teal}{var\textsubscript{e} $x$} refers to a valid binding. By using \textcolor{blue}{Fin n} instead of \textcolor{blue}{$\mathbb{N}$} for $x$, we prevent references to variables that are out of scope.
	
	\subsection{The type of an expression is its typing judgement.}
	
	Instead of implementing LET typing rules separately, which might lead to expressions that are untypeable, we incorporate the typing derivation into the construction of an expression. This is especially useful when the preconditions are linked in some way, for instance in \textbf{case} statements, where the left and right branches must have the same type under the extended environment. So for expressions, we use a data type indexed by value types \textcolor{blue}{$\mathbbm{b}$} and Œì i.e., \textcolor{blue}{Vec $\mathbbm{b}$ n}. A LET expression \textbf{e} is represented in Agda as a value of type \textcolor{blue}{Œì $\vdash$exp: $b$} where \textbf{Œì $\vdash$ e : $b$} according to LET typing rules. Below we present the typing rules for \textbf{fst} and \textbf{case}.	

	\begin{figure}[!htbp]
		
		\begin{subfigure}[b]{0.437\textwidth}
			\centering
			\begin{prooftree}
				\hypo{\begin{tabular}{c}$\Gamma$ $\vdash$ \textit{e} : $b_1 \times b_2$ \end{tabular}}
				\infer1[fst]{\begin{tabular}{c}$\Gamma$ $\vdash$ fst \textit{e} : $b_1$ \end{tabular}}
			\end{prooftree}
				

			
			\label{fig:f6}
			
		\end{subfigure}
		\hfill \vline
		\begin{subfigure}[b]{0.563\textwidth}
			\centering
				\begin{prooftree}
					\hypo{\begin{tabular}{ccc}$\Gamma$  $\vdash$ \textit{e} : $b_1 + b_2$\\$\Gamma$, $x$ : $b_1$  $\vdash$ $e_1$ : $b_3$\\$\Gamma$, $y$ : $b_2$  $\vdash$ $e_2$ : $b_3$\end{tabular}}
					\infer1[case]{\begin{tabular}{c}$\Gamma$  $\vdash$ case \textit{e} in L$x$ $\to$ $e_1$ , R$y$ $\to$ $e_2$: $b_3$\end{tabular}}
				\end{prooftree}

			
			\label{fig:f5}
		\end{subfigure}
		
		And the corresponding Agda constructors:

		\begin{subfigure}[b]{0.38\textwidth}
			\begin{adjustwidth}{-0.8cm}{-1cm}
				\ExecuteMetaData[Languages/Let.tex]{fst-example}
			
		\end{adjustwidth}
	%\caption{fst of a pair}
	\label{fig:f3}
			
		\end{subfigure}
        \hfill \vline
		\begin{subfigure}[b]{0.62\textwidth}
			\begin{adjustwidth}{-0.5cm}{-1cm}
				\ExecuteMetaData[Languages/Let.tex]{case-example}
				\end{adjustwidth}
			%\caption{Branching statement}
			\label{fig:f4}
		\end{subfigure}
		
		\caption{Construction of \textbf{fst} and \textbf{case} expressions using typing rules}

	\end{figure}

	When we use an expression somewhere, say in an interpreter, Œì is known. To form a typeable \textbf{case} expression which is used for branching, we need a LET expression $e$ and a proof that \textbf{Œì $\vdash$ e : $b_1 + b_2$} for some \textbf{$b_1$}, \textbf{$b_2$}. In Agda, this proposition is implicit in the type of $e$, which is its proof. Similarly, we receive $e_1$ and $e_2$ which are proofs that they have the same type \textbf{$b_3$} in environments extended with \textbf{$b_1$} and \textbf{$b_2$} respectively. The typechecker concludes that the \textbf{case} expression we have built will have the type \textbf{$b_3$} in Œì.
	
	This representation has another big advantage:
	
	\subsection{A type-safety proof in the declaration of the interpreter}
	
	\ExecuteMetaData[Languages/Let.tex]{eval-declare}

	LET is a total language so all its constructs will terminate. This fact is verified by Agda's termination checker which ensures that the interpreter \textcolor{blue}{eval\textsubscript{e}} terminates. In addition, we know from the declaration that it terminates with a value of the correct type \textbf{b} given a type environment Œì and an expression $e$ which has type \textbf{b} in Œì. So we have shown that LET is type-safe simply by defining \textcolor{blue}{eval\textsubscript{e}}! The definition of \textcolor{blue}{eval\textsubscript{e}} is conventional. We conclude our discussion of LET with two examples:
	
	\ExecuteMetaData[Languages/Let.tex]{left}
	\ExecuteMetaData[Languages/Let.tex]{let}

\end{document}